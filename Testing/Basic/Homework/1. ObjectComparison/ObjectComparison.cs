using NUnit.Framework;
using NUnit.Framework.Legacy;
using FluentAssertions;

namespace HomeExercise.Tasks.ObjectComparison;
public class ObjectComparison
{
    /// <summary>
    /// Модифицированный метод сравнения объектов с применением FluentAssertions, в частности метода BeEquivalentTo с
    /// дополнительными настройками
    /// Достоинства:
    /// 1.Тест самодостаточен, нам не нужно создавать отдельные от теста вспомогательные методы сравнения объектов и задумываться над тем как их
    ///     правильно называть и где их лучше хранить
    /// 2.Расширяемость, мы не привязываемся к строго определенному набору полей класса, поэтому добавление нового поля не потребует
    ///     от нас модификации теста
    /// 3.Возможность настройки метода, можем как в данном примере явно указать какие поля мы не хотим друг с другом сравнивать, например
    ///     в нашем конкретном случае все объекты имеют разные Id, но при этом с точки зрения определенной нами логики они являются одинаковыми
    ///     и мы можем игнорировать поле Id
    /// 4.Ясность ошибок - FluentAssertions в случае если тест был не пройден предоставит явный конкретный список полей, в которых ожидаемые значения не совпали
    ///     с фактическими, что значительно упростило отладку, к примеру я сходу смог понять что мне нужно исключить сравнение Id-шников объектов, в
    ///     случае альтернативной реализации ниже пришлось бы пользоваться отладчиком и тратить дополнительное время, чтобы определить проблему
    /// 5.Защита от циклических вызовов - FluentAssertions по умолчанию выставляет ограничение в 10 рекурсивных вызовов сравнения вложенных объектов,
    ///     и явно сообщает о наличии циклической зависимости если число рекурсивных вызовов окзалось больше
    /// </summary>
    [Test]
    [Description("Проверка текущего царя")]
    public void CheckCurrentTsar_WithFluentAssertions()
    {
        var actualTsar = TsarRegistry.GetCurrentTsar();

        var expectedTsar = new Person("Ivan IV The Terrible", 54, 170, 70,
            new Person("Vasili III of Russia", 28, 170, 60, null));

        actualTsar.Should().BeEquivalentTo(expectedTsar, options => options
            .Excluding(t => t.Id)
            .Excluding(t => t.Parent.Id));
    }

    /// <summary>
    /// Метод CheckCurrentTsar_WithCustomEquality
    /// Метод позволяет определить совпадает ли полученный из другого метода объект с ожидаемым
    /// 
    /// Особенность в том что мы хотим выделить логику проверки объекта в отдельный метод в котором
    /// сами определяем логику сравнения объектов
    ///
    /// Основные проблемы:
    /// 1. Возможно это была условность задачи, но название теста в целом не отражает суть его назначения, что
    ///     такое 'CustomEquality' сходу не очевидно, и если разработчик хочет понять, то ему нужно лезть в реализацию. Также
    ///     непонятно какое конкретно поведение мы ожидаем от теста, нам нужно чтобы объекты по условию совпали или наоборот мы
    ///     ожидаем что верно определим разные объекты - по названию это непонятно
    /// 
    /// 2. Невозможность явного определения причины падения теста без необходимости лезть в реализацию метода AreEqual
    ///     при таком подходе тест может лишь сообщить нам факт совпадения или несовпадения объектов, а чтобы
    ///     узнать по какой конкретно причине у нас все упало, придется в лучшем случае смотреть реализацию метода AreEqual, а
    ///     скорее всего заниматься отладкой метода.
    ///
    /// 3. Метод для проверки двух объектов отделен от самого теста, и он может оказаться расположенным где-то далеко от самого блока тестирования, а
    ///     то и вовсе выделен в отдельный класс в каком-то другом пакете, и придется проделывать больше лишний манипуляций, тратить лишнее время и
    ///     усилия на то чтобы не просто понять в чем ошибка, а где вообще расположены компоненты теста
    ///
    /// 4. Если у нас много различных объектов в нашем проекте (а их зачастую очень много), то такой подход вынуждает нас писать
    ///     много однотипного кода вкупе с инфраструктурным (тут имею в виду в частности объявление метода), объем
    ///     класса для тестирования начинает расти существенно быстрее причем без явной на то необходимости
    ///
    /// 5. То, что вызвало у меня сомнения, это рекурсивная проверка родителя текущего объекта, в целом это соответствует логике
    ///     сравнения объектов, но тут наверное стоило бы на всякий случай предусмотреть ограничение на глубину вызовов, при желании или
    ///     по неосторожности можно создать ситуацию циклической зависимости и вызвать Stack Overflow Exception, в реализации с FluentAssertions
    ///     по умолчанию установлено ограничение рекурсии в 10 вызовов
    ///
    /// 6. Расширяемость - при такой реализации нужно всегда явно удерживать в голове набор всех полей объекта, иначе есть риск
    ///     забыть добавить проверку в метод, кроме того среда разработки не сообщит нам никаким образом что мы забыли сравнить новые введнные
    ///     нами поля, и что еще хуже - тест тоже ничего не сообщит, в итоге можно попасть в ситуацию когда два на самом деле разных объекта
    ///     по необъяснимой и сходу неочевидной причине могут считаться нашей программой идентичными, что может нарушить логику работы и привести
    ///     к неожиданному поведению программы, тест не выполнит ту цель с которой мы его пишем, а только навредит, убедив нас что
    ///     все работает корректно, хотя на самом деле это не так
    /// </summary>
    [Test]
    [Description("Альтернативное решение. Какие у него недостатки?")]
    public void CheckCurrentTsar_WithCustomEquality()
    {
        var actualTsar = TsarRegistry.GetCurrentTsar();
        var expectedTsar = new Person("Ivan IV The Terrible", 54, 170, 70,
            new Person("Vasili III of Russia", 28, 170, 60, null));

        // Какие недостатки у такого подхода? 
        ClassicAssert.True(AreEqual(actualTsar, expectedTsar));
    }

    private bool AreEqual(Person? actual, Person? expected)
    {
        if (actual == expected) return true;
        if (actual == null || expected == null) return false;
        return
            actual.Name == expected.Name
            && actual.Age == expected.Age
            && actual.Height == expected.Height
            && actual.Weight == expected.Weight
            && AreEqual(actual.Parent, expected.Parent);
    }
}
